{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Poink-and-Clink: A Point & Click Framework for Ink Poink-and-Clink (\"Poink\" for short) is a drop-in replacement for the default web export functionality of Ink , adding simple point & click game functionality. The goal is to make it easy to upgrade a \"text-adventure\"-like Ink story by adding the ability to selectively display layers of an image (including animations) and select choices by clicking on the image; in other words, a minimal set of functionality for writing a point & click adventure in Ink. And if you do your art in Aseprite , there's an export script to streamline the workflow further. Getting Started TODO Link to quickstart tutorial API Reference / list of tags Most features in Poink are implemented using tags (following the precedent set by the default web export functionality in Inky). For a list of supported tags, check HERE (TODO LINK). Design Philosophy Poink is constructed around the following design pillars: Drawing and Writing: Developing a point & click game should involve mostly drawing and writing. You should be able to spend all your time in a drawing program (particularly Aseprite) or in an interactive-narrative-editor (Inky), with as little external programming/configuration as possible. Fully playable as text: Poink is supposed to support prototyping a game in pure text (i.e. playable in Inky) and then progressively adding graphics without removing the full playability of the text content. Done properly, this should hopefully result in games that are screenreader accessible (see section below, though), and that can still be ported to another game engine without much additional effort. Small, quick games: It should be convenient to create small games quickly using Poink. Think jam games, old-school flash games, prototypes, interactive web comics. For highly complex and feature-rich games you might want to go somewhere else. Extensibility: As with conventional Inky web exports, you still have full control over the styling of the interface (via CSS) and the ability to add custom functionality by modifying the relatively-simple JavaScript code. (At some point in the future I would like to rework the JS with a proper API so that you can add variable observers, external functions, and custom line display without even touching main.js ) Limitations Here are some things you can't do easily in Poink: 3rd-person characters walking around in an environment (unless you animate it yourself frame-by-frame). Complex inventory logic, i.e. combining items and \"using\" arbitrary items on arbitrary objects (unless you write it yourself in Ink). Always-present UI elements, i.e. pause menu or \"show inventory\" button (unless you write it yourself in HTML/CSS/JS) (There are ok-ish workarounds for this in Poink, depending on what you're trying to accomplish) But if you don't want any of these features, Poink may be for you! And it should still be relatively simple to modify the JavaScript to add custom functionality, as you could with an Inky web export. A Note on Screenreader Accessibility I have tried my best to make it so that everything is screenreader accessible if you use the TEXTMODE tag. Unfortunately, when there is no visible text onscreen, screenreader navigation in Chrome (and to a lesser extent Firefox) seems to run into some difficulties. If screenreader support is important to you, avoid having moments when there is no text on screen.","title":"Home"},{"location":"#poink-and-clink-a-point-click-framework-for-ink","text":"Poink-and-Clink (\"Poink\" for short) is a drop-in replacement for the default web export functionality of Ink , adding simple point & click game functionality. The goal is to make it easy to upgrade a \"text-adventure\"-like Ink story by adding the ability to selectively display layers of an image (including animations) and select choices by clicking on the image; in other words, a minimal set of functionality for writing a point & click adventure in Ink. And if you do your art in Aseprite , there's an export script to streamline the workflow further.","title":"Poink-and-Clink: A Point &amp; Click Framework for Ink"},{"location":"#getting-started","text":"TODO Link to quickstart tutorial","title":"Getting Started"},{"location":"#api-reference-list-of-tags","text":"Most features in Poink are implemented using tags (following the precedent set by the default web export functionality in Inky). For a list of supported tags, check HERE (TODO LINK).","title":"API Reference / list of tags"},{"location":"#design-philosophy","text":"Poink is constructed around the following design pillars: Drawing and Writing: Developing a point & click game should involve mostly drawing and writing. You should be able to spend all your time in a drawing program (particularly Aseprite) or in an interactive-narrative-editor (Inky), with as little external programming/configuration as possible. Fully playable as text: Poink is supposed to support prototyping a game in pure text (i.e. playable in Inky) and then progressively adding graphics without removing the full playability of the text content. Done properly, this should hopefully result in games that are screenreader accessible (see section below, though), and that can still be ported to another game engine without much additional effort. Small, quick games: It should be convenient to create small games quickly using Poink. Think jam games, old-school flash games, prototypes, interactive web comics. For highly complex and feature-rich games you might want to go somewhere else. Extensibility: As with conventional Inky web exports, you still have full control over the styling of the interface (via CSS) and the ability to add custom functionality by modifying the relatively-simple JavaScript code. (At some point in the future I would like to rework the JS with a proper API so that you can add variable observers, external functions, and custom line display without even touching main.js )","title":"Design Philosophy"},{"location":"#limitations","text":"Here are some things you can't do easily in Poink: 3rd-person characters walking around in an environment (unless you animate it yourself frame-by-frame). Complex inventory logic, i.e. combining items and \"using\" arbitrary items on arbitrary objects (unless you write it yourself in Ink). Always-present UI elements, i.e. pause menu or \"show inventory\" button (unless you write it yourself in HTML/CSS/JS) (There are ok-ish workarounds for this in Poink, depending on what you're trying to accomplish) But if you don't want any of these features, Poink may be for you! And it should still be relatively simple to modify the JavaScript to add custom functionality, as you could with an Inky web export.","title":"Limitations"},{"location":"#a-note-on-screenreader-accessibility","text":"I have tried my best to make it so that everything is screenreader accessible if you use the TEXTMODE tag. Unfortunately, when there is no visible text onscreen, screenreader navigation in Chrome (and to a lesser extent Firefox) seems to run into some difficulties. If screenreader support is important to you, avoid having moments when there is no text on screen.","title":"A Note on Screenreader Accessibility"},{"location":"API/","text":"API Reference Clickable choices A \"clickable\" choice can be created as follows: * [50,50,100,100 kitchen door] -> some_knot This creates a rectangular clickable area whose top-left corner is at 50,50 and whose bottom-right corner is at 100,100 (in pixel coordinates), with the alt text and hover text \"kitchen door.\" In a small abuse of notation, a \"click anywhere\" option can be added as follows: * [,,, Click to continue...] -> some_knot Additional details The alt/hover text is optional, but you really should include it (for code readability and for screenreader accessibility). There should be no spaces between coordinates, and at least one space before the hover text. The origin (0,0) corresponds to the top left of the image, and the y axis increases in the downwards direction. This should match with how pixel coordinates are displayed in most image editing software. When two clickable areas overlap, the one that was added *first* takes precedence. SCENE # SCENE: image.png Set the current contents of the canvas to the specified image. Completely replaces any images that may have been displayed previously. Useful to call once when changing to a new scene. IM_SHOW # IM_SHOW: image.png Adds the specified image into the scene on top of any existing images. IM_HIDE # IM_HIDE: image.png Removes the specified image from the scene. IM_REPLACE # IM_REPLACE: image1.png image2.png Replaces image1 with image2, preserving order of all images. If image1 does not already exist, image2 is simply added to the scene. IM_PREFIX # IM_PREFIX: images/ Set a prefix to be added automatically to all image filename arguments. Useful for grouping images by scene. TEXTMODE Textual description of image # TEXTMODE For accessibility and text-based prototyping in Inky, you can use the TEXTMODE tag for text that will not be displayed to the player in the final export (but will remain accessible to screenreaders). Default Inky Tags The following tags are supported as in Inky default export: # CLEAR # RESTART # CLASS: classname # TITLE: My Cool Game # AUDIO: file.mp3 # AUDIOLOOP: file.mp3 AUDIOLOOP functions slightly differently from Inky: specifying the name of a file that is already playing will not restart the loop. Global Configuration Some global settings can be configured using global tags (tags at the top of the ink file) CANVAS_SHAPE This setting is MANDATORY . # CANVAS_SHAPE: 200 200 Informs the canvas what size the images are going to be (in pixels). If you don't set this correctly then the playing area will not display correctly. CLEAR_AFTER_CHOICES # CLEAR_AFTER_CHOICES: true If set to true, the text will be cleared every time a choice is picked. True by default, as this makes sense for point & click-type games in most cases, although you may sometimes prefer traditional ink behaviour. REPLACE_UNDERSCORES # REPLACE_UNDERSCORES: false If set to true, all underscores in text produced by the Ink story will be replaced with spaces (useful if you want to be lazy and reuse variable names as display text. I would normally not encourage this, but Ink in particular makes it annoying to set display text for some things, so I allow it.) SKIP_CHOICE_TEXT # SKIP_CHOICE_TEXT: false If set to true, the first line of text after a choice is made will be skipped. This basically lets you leave out the [ ] , if you're certain that you would be using it all the time anyways (might save a small number of keystrokes, but to be honest it's probably not worth it).","title":"API Reference"},{"location":"API/#api-reference","text":"","title":"API Reference"},{"location":"API/#clickable-choices","text":"A \"clickable\" choice can be created as follows: * [50,50,100,100 kitchen door] -> some_knot This creates a rectangular clickable area whose top-left corner is at 50,50 and whose bottom-right corner is at 100,100 (in pixel coordinates), with the alt text and hover text \"kitchen door.\" In a small abuse of notation, a \"click anywhere\" option can be added as follows: * [,,, Click to continue...] -> some_knot Additional details The alt/hover text is optional, but you really should include it (for code readability and for screenreader accessibility). There should be no spaces between coordinates, and at least one space before the hover text. The origin (0,0) corresponds to the top left of the image, and the y axis increases in the downwards direction. This should match with how pixel coordinates are displayed in most image editing software. When two clickable areas overlap, the one that was added *first* takes precedence.","title":"Clickable choices"},{"location":"API/#scene","text":"# SCENE: image.png Set the current contents of the canvas to the specified image. Completely replaces any images that may have been displayed previously. Useful to call once when changing to a new scene.","title":"SCENE"},{"location":"API/#im_show","text":"# IM_SHOW: image.png Adds the specified image into the scene on top of any existing images.","title":"IM_SHOW"},{"location":"API/#im_hide","text":"# IM_HIDE: image.png Removes the specified image from the scene.","title":"IM_HIDE"},{"location":"API/#im_replace","text":"# IM_REPLACE: image1.png image2.png Replaces image1 with image2, preserving order of all images. If image1 does not already exist, image2 is simply added to the scene.","title":"IM_REPLACE"},{"location":"API/#im_prefix","text":"# IM_PREFIX: images/ Set a prefix to be added automatically to all image filename arguments. Useful for grouping images by scene.","title":"IM_PREFIX"},{"location":"API/#textmode","text":"Textual description of image # TEXTMODE For accessibility and text-based prototyping in Inky, you can use the TEXTMODE tag for text that will not be displayed to the player in the final export (but will remain accessible to screenreaders).","title":"TEXTMODE"},{"location":"API/#default-inky-tags","text":"The following tags are supported as in Inky default export: # CLEAR # RESTART # CLASS: classname # TITLE: My Cool Game # AUDIO: file.mp3 # AUDIOLOOP: file.mp3 AUDIOLOOP functions slightly differently from Inky: specifying the name of a file that is already playing will not restart the loop.","title":"Default Inky Tags"},{"location":"API/#global-configuration","text":"Some global settings can be configured using global tags (tags at the top of the ink file)","title":"Global Configuration"},{"location":"API/#canvas_shape","text":"This setting is MANDATORY . # CANVAS_SHAPE: 200 200 Informs the canvas what size the images are going to be (in pixels). If you don't set this correctly then the playing area will not display correctly.","title":"CANVAS_SHAPE"},{"location":"API/#clear_after_choices","text":"# CLEAR_AFTER_CHOICES: true If set to true, the text will be cleared every time a choice is picked. True by default, as this makes sense for point & click-type games in most cases, although you may sometimes prefer traditional ink behaviour.","title":"CLEAR_AFTER_CHOICES"},{"location":"API/#replace_underscores","text":"# REPLACE_UNDERSCORES: false If set to true, all underscores in text produced by the Ink story will be replaced with spaces (useful if you want to be lazy and reuse variable names as display text. I would normally not encourage this, but Ink in particular makes it annoying to set display text for some things, so I allow it.)","title":"REPLACE_UNDERSCORES"},{"location":"API/#skip_choice_text","text":"# SKIP_CHOICE_TEXT: false If set to true, the first line of text after a choice is made will be skipped. This basically lets you leave out the [ ] , if you're certain that you would be using it all the time anyways (might save a small number of keystrokes, but to be honest it's probably not worth it).","title":"SKIP_CHOICE_TEXT"},{"location":"tutorial/","text":"Quickstart Tutorial TODO Write a tutorial.","title":"Tutorial"},{"location":"tutorial/#quickstart-tutorial","text":"TODO Write a tutorial.","title":"Quickstart Tutorial"}]}