{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Poink-and-Clink: A Point & Click Framework for Ink Poink-and-Clink (\"Poink\" for short) is a drop-in replacement for the default web export functionality of Ink , adding simple point & click game functionality. The goal is to make it easy to upgrade a \"text-adventure\"-like Ink story by adding the ability to selectively display layers of an image (including animations) and select choices by clicking on the image; in other words, a minimal set of functionality for writing a point & click adventure in Ink. And if you do your art in Aseprite , there's an export script to streamline the workflow further. Getting Started The quickstart tutorial shows how to convert a simple text-based ink game into this demo game . API Reference / list of tags Most features in Poink are implemented using tags (following the precedent set by the default web export functionality in Inky). For a list of supported tags, check the API reference . Design Philosophy Poink is constructed around the following design pillars in mind: Drawing and Writing: Developing a point & click game should involve mostly drawing and writing. You should be able to spend all your time in a drawing program (particularly Aseprite) or in an interactive-narrative-editor (Inky), with as little external programming/configuration as possible. Fully playable as text: Poink is supposed to support prototyping a game in pure text (i.e. playable in Inky) and then progressively adding graphics without removing the full playability of the text content. Done properly, this should hopefully result in games that are screenreader accessible (see section below, though), and that can still be ported to another game engine without much additional effort. Simple, quick games: Poink is obviously not as feature-rich as a dedicated engine like Adventure Game Studio. The intended use case is relatively simple games where using a system like that would be overkill. Think jam games, flash-esque games, prototypes, interactive web comics. For highly complex and feature-rich games you might want to go somewhere else. Limitations Here are some things you can't do easily in Poink: 3rd-person characters walking around in an environment (unless you animate it yourself frame-by-frame). Complex inventory logic, i.e. combining items and \"using\" arbitrary items on arbitrary objects (unless you write it yourself in Ink). Always-present UI elements, i.e. pause menu or \"show inventory\" button (unless you write it yourself in HTML/CSS/JS) (There are ok-ish workarounds for this in Poink, depending on what you're trying to accomplish) But if you don't want any of these features, Poink may be for you! And it should still be relatively simple to modify the JavaScript to add custom functionality, as you could with an Inky web export. A Note on Screenreader Accessibility I have tried my best to make it so that everything is screenreader accessible, including providing the TEXTMODE tag, which allows text to be presented to screenreader users only. Unfortunately, when there is no visible text on screen, screenreader navigation in Chrome (and to a lesser extent Firefox) seems to run into some difficulties. If screenreader support is important to you, avoid relying on the TEXTMODE tag for now and try to convey all relevant information through visible text and hover text. If someone who knows more about screenreaders is able to help with working out the bugs, that would be greatly appreciated!","title":"Home"},{"location":"#poink-and-clink-a-point-click-framework-for-ink","text":"Poink-and-Clink (\"Poink\" for short) is a drop-in replacement for the default web export functionality of Ink , adding simple point & click game functionality. The goal is to make it easy to upgrade a \"text-adventure\"-like Ink story by adding the ability to selectively display layers of an image (including animations) and select choices by clicking on the image; in other words, a minimal set of functionality for writing a point & click adventure in Ink. And if you do your art in Aseprite , there's an export script to streamline the workflow further.","title":"Poink-and-Clink: A Point &amp; Click Framework for Ink"},{"location":"#getting-started","text":"The quickstart tutorial shows how to convert a simple text-based ink game into this demo game .","title":"Getting Started"},{"location":"#api-reference-list-of-tags","text":"Most features in Poink are implemented using tags (following the precedent set by the default web export functionality in Inky). For a list of supported tags, check the API reference .","title":"API Reference / list of tags"},{"location":"#design-philosophy","text":"Poink is constructed around the following design pillars in mind: Drawing and Writing: Developing a point & click game should involve mostly drawing and writing. You should be able to spend all your time in a drawing program (particularly Aseprite) or in an interactive-narrative-editor (Inky), with as little external programming/configuration as possible. Fully playable as text: Poink is supposed to support prototyping a game in pure text (i.e. playable in Inky) and then progressively adding graphics without removing the full playability of the text content. Done properly, this should hopefully result in games that are screenreader accessible (see section below, though), and that can still be ported to another game engine without much additional effort. Simple, quick games: Poink is obviously not as feature-rich as a dedicated engine like Adventure Game Studio. The intended use case is relatively simple games where using a system like that would be overkill. Think jam games, flash-esque games, prototypes, interactive web comics. For highly complex and feature-rich games you might want to go somewhere else.","title":"Design Philosophy"},{"location":"#limitations","text":"Here are some things you can't do easily in Poink: 3rd-person characters walking around in an environment (unless you animate it yourself frame-by-frame). Complex inventory logic, i.e. combining items and \"using\" arbitrary items on arbitrary objects (unless you write it yourself in Ink). Always-present UI elements, i.e. pause menu or \"show inventory\" button (unless you write it yourself in HTML/CSS/JS) (There are ok-ish workarounds for this in Poink, depending on what you're trying to accomplish) But if you don't want any of these features, Poink may be for you! And it should still be relatively simple to modify the JavaScript to add custom functionality, as you could with an Inky web export.","title":"Limitations"},{"location":"#a-note-on-screenreader-accessibility","text":"I have tried my best to make it so that everything is screenreader accessible, including providing the TEXTMODE tag, which allows text to be presented to screenreader users only. Unfortunately, when there is no visible text on screen, screenreader navigation in Chrome (and to a lesser extent Firefox) seems to run into some difficulties. If screenreader support is important to you, avoid relying on the TEXTMODE tag for now and try to convey all relevant information through visible text and hover text. If someone who knows more about screenreaders is able to help with working out the bugs, that would be greatly appreciated!","title":"A Note on Screenreader Accessibility"},{"location":"API/","text":"API Reference Clickable choices A \"clickable\" choice can be created as follows: * [50,50,100,100 kitchen door] -> some_knot This creates a rectangular clickable area whose top-left corner is at 50,50 and whose bottom-right corner is at 100,100 (in pixel coordinates), with the alt text and hover text \"kitchen door.\" In a small abuse of notation, a \"click anywhere\" option can be added as follows: * [,,, Click to continue...] -> some_knot Additional details The alt/hover text is optional, but you really should include it (for code readability and for screenreader accessibility). There should be no spaces between coordinates, and at least one space before the hover text. The origin (0,0) corresponds to the top left of the image, and the y axis increases in the downwards direction. This should match with how pixel coordinates are displayed in most image editing software. When two clickable areas overlap, the one that was added *first* takes precedence. SCENE # SCENE: image.png Set the current contents of the canvas to the specified image. Completely replaces any images that may have been displayed previously. Useful to call once when changing to a new scene. IM_SHOW # IM_SHOW: image.png Adds the specified image into the scene on top of any existing images. IM_HIDE # IM_HIDE: image.png Removes the specified image from the scene. IM_REPLACE # IM_REPLACE: image1.png image2.png Replaces image1 with image2, preserving order of all images. If image1 does not already exist, image2 is simply added to the scene. IM_PREFIX # IM_PREFIX: images/ Set a prefix to be added automatically to all image filename arguments. Useful for grouping images by scene in larger projects. TEXTMODE Textual description of the current scene. # TEXTMODE For accessibility and text-based prototyping in Inky, you can use the TEXTMODE tag for text that will not be displayed to the player in the final export (but will remain accessible to screenreaders). Default Inky Tags The following tags are supported as in Inky default export: # CLEAR # RESTART # CLASS: classname # TITLE: My Cool Game # AUDIO: file.mp3 # AUDIOLOOP: file.mp3 AUDIOLOOP functions slightly differently from Inky: specifying the name of a file that is already playing will not restart the loop. Global Configuration Some global settings can be configured using global tags (tags at the top of the ink file) CANVAS_SHAPE This setting is MANDATORY . # CANVAS_SHAPE: 200 200 Informs the canvas what size the images are going to be (in pixels). If you don't set this correctly then the playing area will not display correctly. CLEAR_AFTER_CHOICES # CLEAR_AFTER_CHOICES: true If set to true, the text will be cleared every time a choice is picked. True by default, as this makes sense for point & click-type games in most cases, although you may sometimes prefer traditional ink behaviour. REPLACE_UNDERSCORES # REPLACE_UNDERSCORES: false If set to true, all underscores in text produced by the Ink story will be replaced with spaces (useful if you want to be lazy and reuse variable names as display text. I would normally not encourage this, but Ink in particular makes it annoying to set display text for some things, so I allow it.) SKIP_CHOICE_TEXT # SKIP_CHOICE_TEXT: false If set to true, the first line of text after a choice is made will be skipped. This basically lets you leave out the [ ] , if you're certain that you would be using it all the time anyways (might save a small number of keystrokes, but to be honest it's probably not worth it).","title":"API Reference"},{"location":"API/#api-reference","text":"","title":"API Reference"},{"location":"API/#clickable-choices","text":"A \"clickable\" choice can be created as follows: * [50,50,100,100 kitchen door] -> some_knot This creates a rectangular clickable area whose top-left corner is at 50,50 and whose bottom-right corner is at 100,100 (in pixel coordinates), with the alt text and hover text \"kitchen door.\" In a small abuse of notation, a \"click anywhere\" option can be added as follows: * [,,, Click to continue...] -> some_knot Additional details The alt/hover text is optional, but you really should include it (for code readability and for screenreader accessibility). There should be no spaces between coordinates, and at least one space before the hover text. The origin (0,0) corresponds to the top left of the image, and the y axis increases in the downwards direction. This should match with how pixel coordinates are displayed in most image editing software. When two clickable areas overlap, the one that was added *first* takes precedence.","title":"Clickable choices"},{"location":"API/#scene","text":"# SCENE: image.png Set the current contents of the canvas to the specified image. Completely replaces any images that may have been displayed previously. Useful to call once when changing to a new scene.","title":"SCENE"},{"location":"API/#im_show","text":"# IM_SHOW: image.png Adds the specified image into the scene on top of any existing images.","title":"IM_SHOW"},{"location":"API/#im_hide","text":"# IM_HIDE: image.png Removes the specified image from the scene.","title":"IM_HIDE"},{"location":"API/#im_replace","text":"# IM_REPLACE: image1.png image2.png Replaces image1 with image2, preserving order of all images. If image1 does not already exist, image2 is simply added to the scene.","title":"IM_REPLACE"},{"location":"API/#im_prefix","text":"# IM_PREFIX: images/ Set a prefix to be added automatically to all image filename arguments. Useful for grouping images by scene in larger projects.","title":"IM_PREFIX"},{"location":"API/#textmode","text":"Textual description of the current scene. # TEXTMODE For accessibility and text-based prototyping in Inky, you can use the TEXTMODE tag for text that will not be displayed to the player in the final export (but will remain accessible to screenreaders).","title":"TEXTMODE"},{"location":"API/#default-inky-tags","text":"The following tags are supported as in Inky default export: # CLEAR # RESTART # CLASS: classname # TITLE: My Cool Game # AUDIO: file.mp3 # AUDIOLOOP: file.mp3 AUDIOLOOP functions slightly differently from Inky: specifying the name of a file that is already playing will not restart the loop.","title":"Default Inky Tags"},{"location":"API/#global-configuration","text":"Some global settings can be configured using global tags (tags at the top of the ink file)","title":"Global Configuration"},{"location":"API/#canvas_shape","text":"This setting is MANDATORY . # CANVAS_SHAPE: 200 200 Informs the canvas what size the images are going to be (in pixels). If you don't set this correctly then the playing area will not display correctly.","title":"CANVAS_SHAPE"},{"location":"API/#clear_after_choices","text":"# CLEAR_AFTER_CHOICES: true If set to true, the text will be cleared every time a choice is picked. True by default, as this makes sense for point & click-type games in most cases, although you may sometimes prefer traditional ink behaviour.","title":"CLEAR_AFTER_CHOICES"},{"location":"API/#replace_underscores","text":"# REPLACE_UNDERSCORES: false If set to true, all underscores in text produced by the Ink story will be replaced with spaces (useful if you want to be lazy and reuse variable names as display text. I would normally not encourage this, but Ink in particular makes it annoying to set display text for some things, so I allow it.)","title":"REPLACE_UNDERSCORES"},{"location":"API/#skip_choice_text","text":"# SKIP_CHOICE_TEXT: false If set to true, the first line of text after a choice is made will be skipped. This basically lets you leave out the [ ] , if you're certain that you would be using it all the time anyways (might save a small number of keystrokes, but to be honest it's probably not worth it).","title":"SKIP_CHOICE_TEXT"},{"location":"tutorial/","text":"Quickstart Tutorial In this tutorial I'll show how to take a simple ink story and \"upgrade\" it to a point & click game. This tutorial assumes familiarity with Ink and Inky. Starting with a text game Consider the following simple ink game: main.ink # TITLE: Simple Ink Game VAR fire_lit = false VAR got_firewood = false VAR player_is_cold = true -> exterior // A little helper tunnel, to give the player an opportunity to read text before it gets cleared === OK === + [Ok] ->-> === exterior === # CLEAR You are stranded deep in the heart of a remote forest. + [dark forest] Towering pines obscure the night sky. {player_is_cold: You know the way home, but the trek will take hours and you are currently extremely cold and damp, on the verge of hypothermia. + [Attempt to walk home] You die of hypothermia before you make it home. You are then eaten by a Grue. GAME OVER. ++ [Try again?] # RESTART -> DONE + [Stay here for now] -> exterior -else: You know the way home, and now that you are warm and dry you believe you can make it home safely. + [Walk home] After many hours hiking through the forest you finally return to civilization. CONGRATULATIONS! ++ [Play again?] # RESTART -> DONE } + {not got_firewood}[pile of firewood] You find some firewood lying near the cabin. ~got_firewood = true -> OK -> exterior + [log cabin] There is an abandoned log cabin nearby. ++ [Enter the cabin] -> interior ++ [Back] -> exterior === interior === # CLEAR You {|once again }find yourself inside {a|the} small cabin.{ It seems like it hasn't been inhabited in quite some time.|} {fire_lit: A fire crackles in the fireplace. - else: The fireplace is cold and dark. } + [fireplace] {not fire_lit: The fireplace is unlit. {got_firewood: Would you like to light it? + [Yes] ~fire_lit = true -> interior + [No] -> interior - else: You could light it if you had some firewood. -> OK -> interior } - else: The fire warms your aching bones and dries your damp clothes. ~player_is_cold = false -> OK -> interior } + [window] It looks cold out there. -> OK -> interior + [door] -> exterior This is a perfectly functional (if somewhat boring) text adventure game. The player is able to navigate between two scenes (interior and exterior), get some firewood, light a fire, warm themselves by the fire, and then walk home. We'll be adding graphics in a moment. For now, though, we can build the text-only version using the Poink template, in essentially the same way that you would export the story normally in Inky. Download the Poink web-template directory. Open Inky and copy-paste in the contents of main.ink Select File > Export story.js only... and overwrite the story.js currently present in the web template. That's it! If you view index.html in a browser you should be able to play the game. Adding background graphics Now it's time to start adding graphics. We'll be using the following five images: Images to be used forest.background.gif: forest.smoke.smoking.gif: forest.woodpile.gif: interior.background.gif: interior.fireplace.burning.gif: Save these images into a folder called images , and put the images folder inside of the web-template folder. Two of the images are opaque backgrounds, and the other three are mostly-transparent sprites meant to be layered on top of one of the backgrounds and selectively shown or hidden depending on the world state. Note that all the images have the same dimensions (96 by 64 pixels) - this is mandatory, and it's a requirement that simplifies the display logic a lot, without impacting expressivity too much, in my opinion. To start with, we have to add some tags at the top of the ink file: # TITLE: Simple Poink Game # CANVAS_SHAPE: 96 64 # IM_PREFIX: images/ The CANVAS_SHAPE tag tells Poink the dimensions of the images we're using, and is mandatory if you want to use the graphical features (which is the entire point of Poink). IM_PREFIX is just a handy shortcut that'll add images/ to the start of all our image filenames, to save some time typing. Now, we'll add a background image to each of the scenes. At the top of each knot, simply add a SCENE tag, like so: === exterior === # CLEAR # SCENE: forest.background.gif ... === interior === # CLEAR # SCENE: interior.background.gif If you re-export story.js now and view index.html again, you should now see background graphics for each knot. Adding sprites / layers Now let's make the graphics to change in response to the world state. Specifically, we'll show the woodpile sprite, but only if the player hasn't yet taken the wood, and we'll also show smoke rising from the cabin chimney if the fire is lit. === exterior === # CLEAR # SCENE: forest.background.gif {not got_firewood: # IM_SHOW: forest.woodpile.gif } {fire_lit: # IM_SHOW: forest.smoke.smoking.gif } You are stranded deep in the heart of a remote forest. This is just using normal Ink if-statements to add an IM_SHOW tag when the appropriate conditions are met. As you might expect, IM_SHOW simply shows an image, on top of any existing images already in the scene. (In contrast, the SCENE tag we saw already will replace all existing images, like you would typically want to do when moving to a new scene). Similarly, presumably we want to show the fire burning in the interior scene: === interior === # CLEAR # SCENE: interior.background.gif You {|once again }find yourself inside {a|the} small cabin.{ It seems like it hasn't been inhabited in quite some time.|} {fire_lit: # IM_SHOW: interior.fireplace.burning.gif A fire crackles in the fireplace. - else: The fireplace is cold and dark. } If you export the project again now, you should find that the graphics all respond appropriately to changes in the world state. Adding click functionality So far we have an illustrated text adventure, but still no pointing or clicking. Let's fix that. We can convert a text link into a clickable area of the image by adding coordinates defining a rectangle to the choice text, as follows: You are stranded deep in the heart of a remote forest. + [0,1,56,48 dark forest] ... + {not got_firewood}[57,42,69,48 pile of firewood] ... + [73,9,96,48 log cabin] ... + [73,28,96,48 fireplace] ... + [31,9,61,32 window] ... + [2,9,27,48 door] ... The text after the coordinates will appear as hover text when the user hovers over the corresponding area of the image, and clicking on that area will select that choice. If you build the template now, you should find that we have a basically fully-functional point & click game. Coordinates are of the form (top-left x, top-left y, bottom-right x, bottom-right y). Now, it may seem annoying to have to look up these coordinates manually, and it is; fortunately, if you use Aseprite then there's a script to do this automatically! See here for more details. TODO WRITE THE PAGE AND LINK TO IT! Hiding text Our game has graphics now, but it still has textual room descriptions (\"You find yourself in the cabin,\" etc), which is unusual for a point & click game. We could, of course, delete those descriptions and let the images (and clickable scenery descriptions) do the talking, but this would make prototyping/testing in Inky less pleasant, not to mention hiding important information from screenreader users. Instead, you can just add the TEXTMODE tag to any lines that you don't want to appear when playing the game, like so: You {|once again }find yourself inside {a|the} small cabin.{ It seems like it hasn't been inhabited in quite some time.|} # TEXTMODE {fire_lit: # IM_SHOW: interior.fireplace.burning.gif A fire crackles in the fireplace. # TEXTMODE - else: The fireplace is cold and dark. # TEXTMODE } We could do the same for the description of the exterior scene, althoug that one actually provides important context (the fact that you're stranded), so we'll conditionally add the tag only after the line has already been shown once: You are stranded deep in the heart of a remote forest. #{|TEXTMODE} That's everything! We now have a finished point & click game. The final result should match the playable demo here . After all the changes we've made, the main.ink code should look like this: # TITLE: Simple Poink Game # IM_PREFIX: images/ # CANVAS_SHAPE: 96 64 VAR fire_lit = false VAR got_firewood = false VAR player_is_cold = true -> exterior // A little helper tunnel, to give the player an opportunity to read text before it gets cleared === OK === + [Ok] ->-> === exterior === # CLEAR # SCENE: forest.background.gif # {not got_firewood: IM_SHOW: forest.woodpile.gif } # {fire_lit: IM_SHOW: forest.smoke.smoking.gif } You are stranded deep in the heart of a remote forest. #{|TEXTMODE} + [0,1,56,48 dark forest] Towering pines obscure the night sky. {player_is_cold: You know the way home, but the trek will take hours and you are currently extremely cold and damp, on the verge of hypothermia. + [Attempt to walk home] You die of hypothermia before you make it home. You are then eaten by a Grue. GAME OVER. ++ [Try again?] # RESTART -> DONE + [Stay here for now] -> exterior -else: You know the way home, and now that you are warm and dry you believe you can make it home safely. + [Walk home] After many hours hiking through the forest you finally return to civilization. CONGRATULATIONS! ++ [Play again?] # RESTART -> DONE } + {not got_firewood}[57,42,69,48 pile of firewood] You find some firewood lying near the cabin. ~got_firewood = true -> OK -> exterior + [73,9,96,48 log cabin] There is an abandoned log cabin nearby. ++ [Enter the cabin] -> interior ++ [Back] -> exterior === interior === # CLEAR # SCENE: interior.background.gif You {|once again }find yourself inside {a|the} small cabin.{ It seems like it hasn't been inhabited in quite some time.|} # TEXTMODE {fire_lit: # IM_SHOW: interior.fireplace.burning.gif A fire crackles in the fireplace. # TEXTMODE - else: The fireplace is cold and dark. # TEXTMODE } + [73,28,96,48 fireplace] {not fire_lit: The fireplace is unlit. {got_firewood: Would you like to light it? + [Yes] ~fire_lit = true -> interior + [No] -> interior - else: You could light it if you had some firewood. -> OK -> interior } - else: The fire warms your aching bones and dries your damp clothes. ~player_is_cold = false -> OK -> interior } + [31,9,61,32 window] It looks cold out there. -> OK -> interior + [2,9,27,48 door] -> exterior","title":"Tutorial"},{"location":"tutorial/#quickstart-tutorial","text":"In this tutorial I'll show how to take a simple ink story and \"upgrade\" it to a point & click game. This tutorial assumes familiarity with Ink and Inky.","title":"Quickstart Tutorial"},{"location":"tutorial/#starting-with-a-text-game","text":"Consider the following simple ink game: main.ink # TITLE: Simple Ink Game VAR fire_lit = false VAR got_firewood = false VAR player_is_cold = true -> exterior // A little helper tunnel, to give the player an opportunity to read text before it gets cleared === OK === + [Ok] ->-> === exterior === # CLEAR You are stranded deep in the heart of a remote forest. + [dark forest] Towering pines obscure the night sky. {player_is_cold: You know the way home, but the trek will take hours and you are currently extremely cold and damp, on the verge of hypothermia. + [Attempt to walk home] You die of hypothermia before you make it home. You are then eaten by a Grue. GAME OVER. ++ [Try again?] # RESTART -> DONE + [Stay here for now] -> exterior -else: You know the way home, and now that you are warm and dry you believe you can make it home safely. + [Walk home] After many hours hiking through the forest you finally return to civilization. CONGRATULATIONS! ++ [Play again?] # RESTART -> DONE } + {not got_firewood}[pile of firewood] You find some firewood lying near the cabin. ~got_firewood = true -> OK -> exterior + [log cabin] There is an abandoned log cabin nearby. ++ [Enter the cabin] -> interior ++ [Back] -> exterior === interior === # CLEAR You {|once again }find yourself inside {a|the} small cabin.{ It seems like it hasn't been inhabited in quite some time.|} {fire_lit: A fire crackles in the fireplace. - else: The fireplace is cold and dark. } + [fireplace] {not fire_lit: The fireplace is unlit. {got_firewood: Would you like to light it? + [Yes] ~fire_lit = true -> interior + [No] -> interior - else: You could light it if you had some firewood. -> OK -> interior } - else: The fire warms your aching bones and dries your damp clothes. ~player_is_cold = false -> OK -> interior } + [window] It looks cold out there. -> OK -> interior + [door] -> exterior This is a perfectly functional (if somewhat boring) text adventure game. The player is able to navigate between two scenes (interior and exterior), get some firewood, light a fire, warm themselves by the fire, and then walk home. We'll be adding graphics in a moment. For now, though, we can build the text-only version using the Poink template, in essentially the same way that you would export the story normally in Inky. Download the Poink web-template directory. Open Inky and copy-paste in the contents of main.ink Select File > Export story.js only... and overwrite the story.js currently present in the web template. That's it! If you view index.html in a browser you should be able to play the game.","title":"Starting with a text game"},{"location":"tutorial/#adding-background-graphics","text":"Now it's time to start adding graphics. We'll be using the following five images: Images to be used forest.background.gif: forest.smoke.smoking.gif: forest.woodpile.gif: interior.background.gif: interior.fireplace.burning.gif: Save these images into a folder called images , and put the images folder inside of the web-template folder. Two of the images are opaque backgrounds, and the other three are mostly-transparent sprites meant to be layered on top of one of the backgrounds and selectively shown or hidden depending on the world state. Note that all the images have the same dimensions (96 by 64 pixels) - this is mandatory, and it's a requirement that simplifies the display logic a lot, without impacting expressivity too much, in my opinion. To start with, we have to add some tags at the top of the ink file: # TITLE: Simple Poink Game # CANVAS_SHAPE: 96 64 # IM_PREFIX: images/ The CANVAS_SHAPE tag tells Poink the dimensions of the images we're using, and is mandatory if you want to use the graphical features (which is the entire point of Poink). IM_PREFIX is just a handy shortcut that'll add images/ to the start of all our image filenames, to save some time typing. Now, we'll add a background image to each of the scenes. At the top of each knot, simply add a SCENE tag, like so: === exterior === # CLEAR # SCENE: forest.background.gif ... === interior === # CLEAR # SCENE: interior.background.gif If you re-export story.js now and view index.html again, you should now see background graphics for each knot.","title":"Adding background graphics"},{"location":"tutorial/#adding-sprites-layers","text":"Now let's make the graphics to change in response to the world state. Specifically, we'll show the woodpile sprite, but only if the player hasn't yet taken the wood, and we'll also show smoke rising from the cabin chimney if the fire is lit. === exterior === # CLEAR # SCENE: forest.background.gif {not got_firewood: # IM_SHOW: forest.woodpile.gif } {fire_lit: # IM_SHOW: forest.smoke.smoking.gif } You are stranded deep in the heart of a remote forest. This is just using normal Ink if-statements to add an IM_SHOW tag when the appropriate conditions are met. As you might expect, IM_SHOW simply shows an image, on top of any existing images already in the scene. (In contrast, the SCENE tag we saw already will replace all existing images, like you would typically want to do when moving to a new scene). Similarly, presumably we want to show the fire burning in the interior scene: === interior === # CLEAR # SCENE: interior.background.gif You {|once again }find yourself inside {a|the} small cabin.{ It seems like it hasn't been inhabited in quite some time.|} {fire_lit: # IM_SHOW: interior.fireplace.burning.gif A fire crackles in the fireplace. - else: The fireplace is cold and dark. } If you export the project again now, you should find that the graphics all respond appropriately to changes in the world state.","title":"Adding sprites / layers"},{"location":"tutorial/#adding-click-functionality","text":"So far we have an illustrated text adventure, but still no pointing or clicking. Let's fix that. We can convert a text link into a clickable area of the image by adding coordinates defining a rectangle to the choice text, as follows: You are stranded deep in the heart of a remote forest. + [0,1,56,48 dark forest] ... + {not got_firewood}[57,42,69,48 pile of firewood] ... + [73,9,96,48 log cabin] ... + [73,28,96,48 fireplace] ... + [31,9,61,32 window] ... + [2,9,27,48 door] ... The text after the coordinates will appear as hover text when the user hovers over the corresponding area of the image, and clicking on that area will select that choice. If you build the template now, you should find that we have a basically fully-functional point & click game. Coordinates are of the form (top-left x, top-left y, bottom-right x, bottom-right y). Now, it may seem annoying to have to look up these coordinates manually, and it is; fortunately, if you use Aseprite then there's a script to do this automatically! See here for more details. TODO WRITE THE PAGE AND LINK TO IT!","title":"Adding click functionality"},{"location":"tutorial/#hiding-text","text":"Our game has graphics now, but it still has textual room descriptions (\"You find yourself in the cabin,\" etc), which is unusual for a point & click game. We could, of course, delete those descriptions and let the images (and clickable scenery descriptions) do the talking, but this would make prototyping/testing in Inky less pleasant, not to mention hiding important information from screenreader users. Instead, you can just add the TEXTMODE tag to any lines that you don't want to appear when playing the game, like so: You {|once again }find yourself inside {a|the} small cabin.{ It seems like it hasn't been inhabited in quite some time.|} # TEXTMODE {fire_lit: # IM_SHOW: interior.fireplace.burning.gif A fire crackles in the fireplace. # TEXTMODE - else: The fireplace is cold and dark. # TEXTMODE } We could do the same for the description of the exterior scene, althoug that one actually provides important context (the fact that you're stranded), so we'll conditionally add the tag only after the line has already been shown once: You are stranded deep in the heart of a remote forest. #{|TEXTMODE} That's everything! We now have a finished point & click game. The final result should match the playable demo here . After all the changes we've made, the main.ink code should look like this: # TITLE: Simple Poink Game # IM_PREFIX: images/ # CANVAS_SHAPE: 96 64 VAR fire_lit = false VAR got_firewood = false VAR player_is_cold = true -> exterior // A little helper tunnel, to give the player an opportunity to read text before it gets cleared === OK === + [Ok] ->-> === exterior === # CLEAR # SCENE: forest.background.gif # {not got_firewood: IM_SHOW: forest.woodpile.gif } # {fire_lit: IM_SHOW: forest.smoke.smoking.gif } You are stranded deep in the heart of a remote forest. #{|TEXTMODE} + [0,1,56,48 dark forest] Towering pines obscure the night sky. {player_is_cold: You know the way home, but the trek will take hours and you are currently extremely cold and damp, on the verge of hypothermia. + [Attempt to walk home] You die of hypothermia before you make it home. You are then eaten by a Grue. GAME OVER. ++ [Try again?] # RESTART -> DONE + [Stay here for now] -> exterior -else: You know the way home, and now that you are warm and dry you believe you can make it home safely. + [Walk home] After many hours hiking through the forest you finally return to civilization. CONGRATULATIONS! ++ [Play again?] # RESTART -> DONE } + {not got_firewood}[57,42,69,48 pile of firewood] You find some firewood lying near the cabin. ~got_firewood = true -> OK -> exterior + [73,9,96,48 log cabin] There is an abandoned log cabin nearby. ++ [Enter the cabin] -> interior ++ [Back] -> exterior === interior === # CLEAR # SCENE: interior.background.gif You {|once again }find yourself inside {a|the} small cabin.{ It seems like it hasn't been inhabited in quite some time.|} # TEXTMODE {fire_lit: # IM_SHOW: interior.fireplace.burning.gif A fire crackles in the fireplace. # TEXTMODE - else: The fireplace is cold and dark. # TEXTMODE } + [73,28,96,48 fireplace] {not fire_lit: The fireplace is unlit. {got_firewood: Would you like to light it? + [Yes] ~fire_lit = true -> interior + [No] -> interior - else: You could light it if you had some firewood. -> OK -> interior } - else: The fire warms your aching bones and dries your damp clothes. ~player_is_cold = false -> OK -> interior } + [31,9,61,32 window] It looks cold out there. -> OK -> interior + [2,9,27,48 door] -> exterior","title":"Hiding text"}]}